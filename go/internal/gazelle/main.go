// Package gazelle is a gazelle plugin that adds nfpm_package rules for each .nfpm.yaml file it finds.
package gazelle

import (
	"flag"
	"io/ioutil"
	"log"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

type nfpmLanguage struct{}

// NewLanguage returns a gazelle language plugin.
func NewLanguage() language.Language {
	return &nfpmLanguage{}
}

// Name returns the name of the language. This should be a prefix of the kinds of rules generated by
// the language, e.g., "go" for the Go extension since it generates "go_library" rules.
//
// Since we are generating nfpm_package rules, we return "nfpm".
func (nfpmLanguage) Name() string {
	return "nfpm"
}

// Kinds returns a map of maps rule names (kinds) and information on how to match and merge
// attributes that may be found in rules of those kinds. All kinds of rules generated for this
// language may be found here.
func (nfpmLanguage) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"nfpm_package": {
			// MatchAttrs is a list of attributes used in matching. For example, for go_library, this list
			// contains "importpath". Attributes are matched in order.
			//
			// Because each config file may be used for both a debian and an rpm package, we cannot match
			// on config, so we match on name.
			MatchAttrs: []string{"name"},

			// ResolveAttrs is a set of attributes that should be merged after
			// dependency resolution. See rule.Merge.
			ResolveAttrs: map[string]bool{"deps": true},
		},
	}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (nfpmLanguage) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name:    "@com_github_ericnorris_rules_nfpm//nfpm:defs.bzl",
			Symbols: []string{"nfpm_package"},
		},
	}
}

var _dependencyRegex = regexp.MustCompile("{{ index .Dependencies `(.*)`}}")

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// A GenerateResult struct is returned. Optional fields may be added to this
// type in the future.
//
// Any non-fatal errors this function encounters should be logged using
// log.Print.
func (nfpmLanguage) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	rules := make([]*rule.Rule, 0)
	imports := make([]interface{}, 0)
	for _, file := range args.RegularFiles {
		if strings.HasSuffix(file, ".nfpm.yaml") {
			deps := dependenciesFromYaml(args.Dir, file, "//"+args.Rel)
			baseName := file[:len(file)-len(".nfpm.yaml")]

			deb := makeRule(baseName+".deb", file, deps)
			rpm := makeRule(baseName+".rpm", file, deps)

			rules = append(rules, deb, rpm)
			imports = append(imports, nil, nil)
		}
	}

	return language.GenerateResult{
		Gen:     rules,
		Imports: imports,
	}
}

func dependenciesFromYaml(dir, file, rel string) []string {
	// ioutil.ReadFile can be replaced with os.ReadFile when we rely on go 1.16.
	bytes, err := ioutil.ReadFile(filepath.Join(dir, file))
	if err != nil {
		log.Printf("Failed to read file due to %+v", err)
		return nil
	}
	matches := _dependencyRegex.FindAllStringSubmatch(string(bytes), -1)
	deps := make([]string, len(matches))
	for i, ms := range matches {
		m := ms[1]
		if strings.HasPrefix(m, rel) {
			deps[i] = m[len(rel):]
		} else {
			deps[i] = m
		}
	}
	return deps
}

func makeRule(name, config string, deps []string) *rule.Rule {
	r := rule.NewRule("nfpm_package", name)
	r.SetAttr("config", config)
	r.SetAttr("deps", deps)
	return r
}

func (nfpmLanguage) RegisterFlags(fs *flag.FlagSet, cmd string, c *config.Config) {
}

func (nfpmLanguage) CheckFlags(fs *flag.FlagSet, c *config.Config) error {
	return nil
}

func (nfpmLanguage) KnownDirectives() []string {
	return nil
}

func (nfpmLanguage) Configure(c *config.Config, rel string, f *rule.File) {
}

func (nfpmLanguage) Fix(c *config.Config, f *rule.File) {
}

func (nfpmLanguage) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	return nil
}

func (nfpmLanguage) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return nil
}

func (nfpmLanguage) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, imports interface{}, from label.Label) {
}
